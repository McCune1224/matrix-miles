// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: logs.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const cleanupOldLogs = `-- name: CleanupOldLogs :exec
DELETE FROM application_logs
WHERE timestamp < $1
`

func (q *Queries) CleanupOldLogs(ctx context.Context, timestamp pgtype.Timestamp) error {
	_, err := q.db.Exec(ctx, cleanupOldLogs, timestamp)
	return err
}

const getLogsByLevel = `-- name: GetLogsByLevel :many
SELECT id, level, message, timestamp, caller, stack_trace, fields, created_at FROM application_logs
WHERE level = $1
  AND timestamp >= $2
ORDER BY timestamp DESC
LIMIT $3
`

type GetLogsByLevelParams struct {
	Level     string           `json:"level"`
	Timestamp pgtype.Timestamp `json:"timestamp"`
	Limit     int32            `json:"limit"`
}

func (q *Queries) GetLogsByLevel(ctx context.Context, arg GetLogsByLevelParams) ([]ApplicationLog, error) {
	rows, err := q.db.Query(ctx, getLogsByLevel, arg.Level, arg.Timestamp, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ApplicationLog{}
	for rows.Next() {
		var i ApplicationLog
		if err := rows.Scan(
			&i.ID,
			&i.Level,
			&i.Message,
			&i.Timestamp,
			&i.Caller,
			&i.StackTrace,
			&i.Fields,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLogsByUserID = `-- name: GetLogsByUserID :many
SELECT id, level, message, timestamp, caller, stack_trace, fields, created_at FROM application_logs
WHERE fields->>'user_id' = $1
  AND timestamp >= $2
ORDER BY timestamp DESC
LIMIT $3
`

type GetLogsByUserIDParams struct {
	Fields    []byte           `json:"fields"`
	Timestamp pgtype.Timestamp `json:"timestamp"`
	Limit     int32            `json:"limit"`
}

func (q *Queries) GetLogsByUserID(ctx context.Context, arg GetLogsByUserIDParams) ([]ApplicationLog, error) {
	rows, err := q.db.Query(ctx, getLogsByUserID, arg.Fields, arg.Timestamp, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ApplicationLog{}
	for rows.Next() {
		var i ApplicationLog
		if err := rows.Scan(
			&i.ID,
			&i.Level,
			&i.Message,
			&i.Timestamp,
			&i.Caller,
			&i.StackTrace,
			&i.Fields,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentLogs = `-- name: GetRecentLogs :many
SELECT id, level, message, timestamp, caller, stack_trace, fields, created_at FROM application_logs
WHERE timestamp >= $1
ORDER BY timestamp DESC
LIMIT $2
`

type GetRecentLogsParams struct {
	Timestamp pgtype.Timestamp `json:"timestamp"`
	Limit     int32            `json:"limit"`
}

func (q *Queries) GetRecentLogs(ctx context.Context, arg GetRecentLogsParams) ([]ApplicationLog, error) {
	rows, err := q.db.Query(ctx, getRecentLogs, arg.Timestamp, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ApplicationLog{}
	for rows.Next() {
		var i ApplicationLog
		if err := rows.Scan(
			&i.ID,
			&i.Level,
			&i.Message,
			&i.Timestamp,
			&i.Caller,
			&i.StackTrace,
			&i.Fields,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

type InsertLogBatchParams struct {
	Level      string           `json:"level"`
	Message    string           `json:"message"`
	Timestamp  pgtype.Timestamp `json:"timestamp"`
	Caller     pgtype.Text      `json:"caller"`
	StackTrace pgtype.Text      `json:"stack_trace"`
	Fields     []byte           `json:"fields"`
}
