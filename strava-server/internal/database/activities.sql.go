// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: activities.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createActivity = `-- name: CreateActivity :one
INSERT INTO activities (
    user_id,
    strava_activity_id,
    name,
    type,
    distance,
    moving_time,
    elapsed_time,
    start_date,
    start_date_local
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, user_id, strava_activity_id, name, type, distance, moving_time, elapsed_time, start_date, start_date_local, created_at
`

type CreateActivityParams struct {
	UserID           int32            `json:"user_id"`
	StravaActivityID int64            `json:"strava_activity_id"`
	Name             pgtype.Text      `json:"name"`
	Type             pgtype.Text      `json:"type"`
	Distance         pgtype.Float8    `json:"distance"`
	MovingTime       pgtype.Int4      `json:"moving_time"`
	ElapsedTime      pgtype.Int4      `json:"elapsed_time"`
	StartDate        pgtype.Timestamp `json:"start_date"`
	StartDateLocal   pgtype.Timestamp `json:"start_date_local"`
}

func (q *Queries) CreateActivity(ctx context.Context, arg CreateActivityParams) (Activity, error) {
	row := q.db.QueryRow(ctx, createActivity,
		arg.UserID,
		arg.StravaActivityID,
		arg.Name,
		arg.Type,
		arg.Distance,
		arg.MovingTime,
		arg.ElapsedTime,
		arg.StartDate,
		arg.StartDateLocal,
	)
	var i Activity
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.StravaActivityID,
		&i.Name,
		&i.Type,
		&i.Distance,
		&i.MovingTime,
		&i.ElapsedTime,
		&i.StartDate,
		&i.StartDateLocal,
		&i.CreatedAt,
	)
	return i, err
}

const deleteActivity = `-- name: DeleteActivity :exec
DELETE FROM activities
WHERE id = $1
`

func (q *Queries) DeleteActivity(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteActivity, id)
	return err
}

const getActivitiesByDateRange = `-- name: GetActivitiesByDateRange :many
SELECT id, user_id, strava_activity_id, name, type, distance, moving_time, elapsed_time, start_date, start_date_local, created_at FROM activities
WHERE user_id = $1
  AND start_date >= $2
  AND start_date <= $3
ORDER BY start_date DESC
`

type GetActivitiesByDateRangeParams struct {
	UserID      int32            `json:"user_id"`
	StartDate   pgtype.Timestamp `json:"start_date"`
	StartDate_2 pgtype.Timestamp `json:"start_date_2"`
}

func (q *Queries) GetActivitiesByDateRange(ctx context.Context, arg GetActivitiesByDateRangeParams) ([]Activity, error) {
	rows, err := q.db.Query(ctx, getActivitiesByDateRange, arg.UserID, arg.StartDate, arg.StartDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Activity{}
	for rows.Next() {
		var i Activity
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.StravaActivityID,
			&i.Name,
			&i.Type,
			&i.Distance,
			&i.MovingTime,
			&i.ElapsedTime,
			&i.StartDate,
			&i.StartDateLocal,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActivity = `-- name: GetActivity :one
SELECT id, user_id, strava_activity_id, name, type, distance, moving_time, elapsed_time, start_date, start_date_local, created_at FROM activities
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetActivity(ctx context.Context, id int32) (Activity, error) {
	row := q.db.QueryRow(ctx, getActivity, id)
	var i Activity
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.StravaActivityID,
		&i.Name,
		&i.Type,
		&i.Distance,
		&i.MovingTime,
		&i.ElapsedTime,
		&i.StartDate,
		&i.StartDateLocal,
		&i.CreatedAt,
	)
	return i, err
}

const getActivityByStravaID = `-- name: GetActivityByStravaID :one
SELECT id, user_id, strava_activity_id, name, type, distance, moving_time, elapsed_time, start_date, start_date_local, created_at FROM activities
WHERE strava_activity_id = $1 LIMIT 1
`

func (q *Queries) GetActivityByStravaID(ctx context.Context, stravaActivityID int64) (Activity, error) {
	row := q.db.QueryRow(ctx, getActivityByStravaID, stravaActivityID)
	var i Activity
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.StravaActivityID,
		&i.Name,
		&i.Type,
		&i.Distance,
		&i.MovingTime,
		&i.ElapsedTime,
		&i.StartDate,
		&i.StartDateLocal,
		&i.CreatedAt,
	)
	return i, err
}

const getActivityStats = `-- name: GetActivityStats :one
SELECT 
    COUNT(*) as total_activities,
    COALESCE(SUM(distance), 0) as total_distance,
    COALESCE(SUM(moving_time), 0) as total_time
FROM activities
WHERE user_id = $1
`

type GetActivityStatsRow struct {
	TotalActivities int64       `json:"total_activities"`
	TotalDistance   interface{} `json:"total_distance"`
	TotalTime       interface{} `json:"total_time"`
}

func (q *Queries) GetActivityStats(ctx context.Context, userID int32) (GetActivityStatsRow, error) {
	row := q.db.QueryRow(ctx, getActivityStats, userID)
	var i GetActivityStatsRow
	err := row.Scan(&i.TotalActivities, &i.TotalDistance, &i.TotalTime)
	return i, err
}

const getCalendarData = `-- name: GetCalendarData :many
SELECT 
    DATE(start_date) as activity_date,
    COUNT(*) as count,
    SUM(distance) as total_distance
FROM activities
WHERE user_id = $1
  AND start_date >= $2
  AND start_date <= $3
GROUP BY DATE(start_date)
ORDER BY activity_date
`

type GetCalendarDataParams struct {
	UserID      int32            `json:"user_id"`
	StartDate   pgtype.Timestamp `json:"start_date"`
	StartDate_2 pgtype.Timestamp `json:"start_date_2"`
}

type GetCalendarDataRow struct {
	ActivityDate  pgtype.Date `json:"activity_date"`
	Count         int64       `json:"count"`
	TotalDistance int64       `json:"total_distance"`
}

func (q *Queries) GetCalendarData(ctx context.Context, arg GetCalendarDataParams) ([]GetCalendarDataRow, error) {
	rows, err := q.db.Query(ctx, getCalendarData, arg.UserID, arg.StartDate, arg.StartDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCalendarDataRow{}
	for rows.Next() {
		var i GetCalendarDataRow
		if err := rows.Scan(&i.ActivityDate, &i.Count, &i.TotalDistance); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentActivities = `-- name: GetRecentActivities :many
SELECT id, user_id, strava_activity_id, name, type, distance, moving_time, elapsed_time, start_date, start_date_local, created_at FROM activities
WHERE user_id = $1
ORDER BY start_date DESC
LIMIT $2
`

type GetRecentActivitiesParams struct {
	UserID int32 `json:"user_id"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) GetRecentActivities(ctx context.Context, arg GetRecentActivitiesParams) ([]Activity, error) {
	rows, err := q.db.Query(ctx, getRecentActivities, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Activity{}
	for rows.Next() {
		var i Activity
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.StravaActivityID,
			&i.Name,
			&i.Type,
			&i.Distance,
			&i.MovingTime,
			&i.ElapsedTime,
			&i.StartDate,
			&i.StartDateLocal,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActivitiesByUser = `-- name: ListActivitiesByUser :many
SELECT id, user_id, strava_activity_id, name, type, distance, moving_time, elapsed_time, start_date, start_date_local, created_at FROM activities
WHERE user_id = $1
ORDER BY start_date DESC
LIMIT $2 OFFSET $3
`

type ListActivitiesByUserParams struct {
	UserID int32 `json:"user_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListActivitiesByUser(ctx context.Context, arg ListActivitiesByUserParams) ([]Activity, error) {
	rows, err := q.db.Query(ctx, listActivitiesByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Activity{}
	for rows.Next() {
		var i Activity
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.StravaActivityID,
			&i.Name,
			&i.Type,
			&i.Distance,
			&i.MovingTime,
			&i.ElapsedTime,
			&i.StartDate,
			&i.StartDateLocal,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertActivity = `-- name: UpsertActivity :one
INSERT INTO activities (
    user_id,
    strava_activity_id,
    name,
    type,
    distance,
    moving_time,
    elapsed_time,
    start_date,
    start_date_local
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
)
ON CONFLICT (strava_activity_id)
DO UPDATE SET
    name = EXCLUDED.name,
    type = EXCLUDED.type,
    distance = EXCLUDED.distance,
    moving_time = EXCLUDED.moving_time,
    elapsed_time = EXCLUDED.elapsed_time,
    start_date = EXCLUDED.start_date,
    start_date_local = EXCLUDED.start_date_local
RETURNING id, user_id, strava_activity_id, name, type, distance, moving_time, elapsed_time, start_date, start_date_local, created_at
`

type UpsertActivityParams struct {
	UserID           int32            `json:"user_id"`
	StravaActivityID int64            `json:"strava_activity_id"`
	Name             pgtype.Text      `json:"name"`
	Type             pgtype.Text      `json:"type"`
	Distance         pgtype.Float8    `json:"distance"`
	MovingTime       pgtype.Int4      `json:"moving_time"`
	ElapsedTime      pgtype.Int4      `json:"elapsed_time"`
	StartDate        pgtype.Timestamp `json:"start_date"`
	StartDateLocal   pgtype.Timestamp `json:"start_date_local"`
}

func (q *Queries) UpsertActivity(ctx context.Context, arg UpsertActivityParams) (Activity, error) {
	row := q.db.QueryRow(ctx, upsertActivity,
		arg.UserID,
		arg.StravaActivityID,
		arg.Name,
		arg.Type,
		arg.Distance,
		arg.MovingTime,
		arg.ElapsedTime,
		arg.StartDate,
		arg.StartDateLocal,
	)
	var i Activity
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.StravaActivityID,
		&i.Name,
		&i.Type,
		&i.Distance,
		&i.MovingTime,
		&i.ElapsedTime,
		&i.StartDate,
		&i.StartDateLocal,
		&i.CreatedAt,
	)
	return i, err
}
